<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Snake - Retro Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = { darkMode: 'class' }</script>
    <style>
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        @font-face {
            font-family: 'PressStart2P';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        }
        .pixel-font {
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-4 pixel-font">PIXEL SNAKE</h1>
            <p class="text-gray-600 dark:text-gray-300 mb-4">Classic 8-bit snake game</p>
            <a href="../../index.html" class="text-blue-600 dark:text-blue-400 hover:underline">← Back to Portfolio</a>
        </div>
        
        <div class="max-w-2xl mx-auto">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
                <div class="flex justify-between items-center mb-6">
                    <div class="text-lg font-semibold pixel-font">SCORE: <span id="score">0</span></div>
                    <div class="text-lg font-semibold pixel-font">HIGH SCORE: <span id="high-score">0</span></div>
                </div>
                
                <div class="flex justify-center mb-6">
                    <canvas id="game-canvas" width="400" height="400" class="border-4 border-gray-800 dark:border-gray-600"></canvas>
                </div>
                
                <div id="game-over" class="hidden text-center mb-6">
                    <div class="text-2xl font-bold text-red-600 dark:text-red-400 pixel-font">GAME OVER</div>
                    <div class="text-lg mt-2 pixel-font">PRESS SPACE TO RESTART</div>
                </div>
                
                <div class="flex justify-center gap-4">
                    <button id="start-btn" class="bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700 pixel-font">START</button>
                    <button id="pause-btn" class="bg-yellow-600 text-white px-6 py-2 rounded hover:bg-yellow-700 pixel-font">PAUSE</button>
                </div>
                
                <div class="mt-6 text-center">
                    <div class="text-lg font-semibold mb-2 pixel-font">CONTROLS</div>
                    <div class="grid grid-cols-3 gap-2 max-w-xs mx-auto">
                        <div></div>
                        <button id="up-btn" class="bg-gray-200 dark:bg-gray-700 p-2 rounded">↑</button>
                        <div></div>
                        <button id="left-btn" class="bg-gray-200 dark:bg-gray-700 p-2 rounded">←</button>
                        <button id="down-btn" class="bg-gray-200 dark:bg-gray-700 p-2 rounded">↓</button>
                        <button id="right-btn" class="bg-gray-200 dark:bg-gray-700 p-2 rounded">→</button>
                    </div>
                    <div class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                        Use arrow keys or buttons to control the snake
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('high-score');
        const gameOverElement = document.getElementById('game-over');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        
        // Game settings
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        const colors = {
            background: '#000000',
            snake: '#00FF00',
            food: '#FF0000',
            border: '#333333',
            grid: '#111111'
        };
        
        // Game state
        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameSpeed = 100; // milliseconds
        let gameLoop;
        let isPaused = false;
        let isGameOver = false;
        
        // Initialize game
        function initGame() {
            // Reset game state
            snake = [
                {x: 5, y: 10},
                {x: 4, y: 10},
                {x: 3, y: 10}
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            scoreElement.textContent = score;
            highScoreElement.textContent = highScore;
            gameOverElement.classList.add('hidden');
            isGameOver = false;
            isPaused = false;
            
            // Generate first food
            generateFood();
            
            // Start game loop
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(updateGame, gameSpeed);
            
            // Update button states
            startBtn.textContent = 'RESTART';
            pauseBtn.textContent = 'PAUSE';
        }
        
        // Generate food at random position
        function generateFood() {
            // Generate random position
            let x, y;
            let validPosition = false;
            
            while (!validPosition) {
                x = Math.floor(Math.random() * tileCount);
                y = Math.floor(Math.random() * tileCount);
                
                // Check if position is not occupied by snake
                validPosition = true;
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === x && snake[i].y === y) {
                        validPosition = false;
                        break;
                    }
                }
            }
            
            food = {x, y};
        }
        
        // Update game state
        function updateGame() {
            if (isPaused || isGameOver) return;
            
            // Update direction
            direction = nextDirection;
            
            // Move snake
            const head = {x: snake[0].x, y: snake[0].y};
            
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            // Check for collisions
            if (
                head.x < 0 || head.x >= tileCount ||
                head.y < 0 || head.y >= tileCount ||
                checkSnakeCollision(head)
            ) {
                gameOver();
                return;
            }
            
            // Check if food is eaten
            const ateFood = head.x === food.x && head.y === food.y;
            
            // Add new head
            snake.unshift(head);
            
            // If food is eaten, generate new food, otherwise remove tail
            if (ateFood) {
                score++;
                scoreElement.textContent = score;
                
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    highScoreElement.textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore);
                }
                
                // Generate new food
                generateFood();
                
                // Increase speed slightly
                if (score % 5 === 0 && gameSpeed > 50) {
                    clearInterval(gameLoop);
                    gameSpeed -= 5;
                    gameLoop = setInterval(updateGame, gameSpeed);
                }
                
                // Play eat sound
                playSound('eat');
            } else {
                snake.pop();
            }
            
            // Draw game
            drawGame();
        }
        
        // Check if head collides with snake body
        function checkSnakeCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }
        
        // Draw game
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.fillStyle = colors.grid;
            for (let x = 0; x < tileCount; x++) {
                for (let y = 0; y < tileCount; y++) {
                    ctx.fillRect(x * gridSize + 1, y * gridSize + 1, gridSize - 2, gridSize - 2);
                }
            }
            
            // Draw food
            ctx.fillStyle = colors.food;
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);
            
            // Draw snake
            ctx.fillStyle = colors.snake;
            for (let i = 0; i < snake.length; i++) {
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize, gridSize);
                
                // Draw eyes on head
                if (i === 0) {
                    ctx.fillStyle = '#000000';
                    
                    // Position eyes based on direction
                    let eyeX1, eyeY1, eyeX2, eyeY2;
                    const eyeSize = gridSize / 5;
                    const eyeOffset = gridSize / 3;
                    
                    switch (direction) {
                        case 'up':
                            eyeX1 = snake[0].x * gridSize + eyeOffset;
                            eyeY1 = snake[0].y * gridSize + eyeOffset;
                            eyeX2 = snake[0].x * gridSize + gridSize - eyeOffset - eyeSize;
                            eyeY2 = snake[0].y * gridSize + eyeOffset;
                            break;
                        case 'down':
                            eyeX1 = snake[0].x * gridSize + eyeOffset;
                            eyeY1 = snake[0].y * gridSize + gridSize - eyeOffset - eyeSize;
                            eyeX2 = snake[0].x * gridSize + gridSize - eyeOffset - eyeSize;
                            eyeY2 = snake[0].y * gridSize + gridSize - eyeOffset - eyeSize;
                            break;
                        case 'left':
                            eyeX1 = snake[0].x * gridSize + eyeOffset;
                            eyeY1 = snake[0].y * gridSize + eyeOffset;
                            eyeX2 = snake[0].x * gridSize + eyeOffset;
                            eyeY2 = snake[0].y * gridSize + gridSize - eyeOffset - eyeSize;
                            break;
                        case 'right':
                            eyeX1 = snake[0].x * gridSize + gridSize - eyeOffset - eyeSize;
                            eyeY1 = snake[0].y * gridSize + eyeOffset;
                            eyeX2 = snake[0].x * gridSize + gridSize - eyeOffset - eyeSize;
                            eyeY2 = snake[0].y * gridSize + gridSize - eyeOffset - eyeSize;
                            break;
                    }
                    
                    ctx.fillRect(eyeX1, eyeY1, eyeSize, eyeSize);
                    ctx.fillRect(eyeX2, eyeY2, eyeSize, eyeSize);
                }
            }
        }
        
        // Game over
        function gameOver() {
            clearInterval(gameLoop);
            isGameOver = true;
            gameOverElement.classList.remove('hidden');
            playSound('gameover');
        }
        
        // Toggle pause
        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'RESUME' : 'PAUSE';
        }
        
        // Play sound
        function playSound(type) {
            // Simple beep sounds using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'eat':
                    oscillator.type = 'square';
                    oscillator.frequency.value = 440;
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    setTimeout(() => oscillator.stop(), 100);
                    break;
                case 'gameover':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.value = 200;
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    
                    // Descending tone
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    setTimeout(() => oscillator.stop(), 500);
                    break;
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            // Prevent default action for arrow keys to avoid scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // Handle direction changes
            switch (e.key) {
                case 'ArrowUp':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
                case ' ':
                    if (isGameOver) initGame();
                    else togglePause();
                    break;
            }
        });
        
        // Touch controls
        upBtn.addEventListener('click', () => {
            if (direction !== 'down') nextDirection = 'up';
        });
        
        downBtn.addEventListener('click', () => {
            if (direction !== 'up') nextDirection = 'down';
        });
        
        leftBtn.addEventListener('click', () => {
            if (direction !== 'right') nextDirection = 'left';
        });
        
        rightBtn.addEventListener('click', () => {
            if (direction !== 'left') nextDirection = 'right';
        });
        
        // Button controls
        startBtn.addEventListener('click', initGame);
        pauseBtn.addEventListener('click', togglePause);
        
        // Initial draw
        drawGame();
        highScoreElement.textContent = highScore;
    </script>
</body>
</html>