<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2048 Game - Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
        }
        /* Custom styles for tile colors, gradients, and shadows */
        .tile {
            transition: all 0.2s ease-in-out;
            box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 6px -1px, rgba(0, 0, 0, 0.06) 0px 2px 4px -1px;
        }
        .tile-2 { background-image: linear-gradient(to top, #eee4da, #f2ede7); color: #776e65; }
        .tile-4 { background-image: linear-gradient(to top, #ede0c8, #efdfcc); color: #776e65; }
        .tile-8 { background-image: linear-gradient(to top, #f2b179, #f5b986); color: #f9f6f2; }
        .tile-16 { background-image: linear-gradient(to top, #f59563, #f69f71); color: #f9f6f2; }
        .tile-32 { background-image: linear-gradient(to top, #f67c5f, #f7886f); color: #f9f6f2; }
        .tile-64 { background-image: linear-gradient(to top, #f65e3b, #f76e4c); color: #f9f6f2; }
        .tile-128 { background-image: linear-gradient(to top, #edcf72, #efd57e); color: #f9f6f2; }
        .tile-256 { background-image: linear-gradient(to top, #edcc61, #efd26e); color: #f9f6f2; }
        .tile-512 { background-image: linear-gradient(to top, #edc850, #efce5d); color: #f9f6f2; }
        .tile-1024 { background-image: linear-gradient(to top, #edc53f, #efcb4c); color: #f9f6f2; font-size: 2rem; }
        .tile-2048 { background-image: linear-gradient(to top, #edc22e, #efc83b); color: #f9f6f2; font-size: 2rem; }
        .tile-super { background-image: linear-gradient(to top, #3c3a32, #4c4a42); color: #f9f6f2; font-size: 2rem; }

        /* Animation for new tiles */
        @keyframes appear {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        .tile-new {
            animation: appear 0.2s ease-out;
        }
        
        /* Animation for score update */
        @keyframes score-update {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .score-updated {
            animation: score-update 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-800 text-gray-800 dark:text-white min-h-screen flex flex-col items-center justify-center p-4 select-none">

    <div class="text-center mb-6">
        <h1 class="text-6xl font-bold mb-2 text-gray-700 dark:text-gray-200">2048</h1>
        <p class="text-gray-500 dark:text-gray-400">Join the numbers to get to the <strong>2048</strong> tile!</p>
    </div>

    <div class="flex items-center gap-4 mb-4">
        <div class="bg-gray-700 p-3 rounded-lg text-center min-w-[100px]">
            <div class="text-gray-300 text-sm font-bold uppercase tracking-wider">Score</div>
            <div id="score" class="text-3xl font-bold text-white transition-transform duration-300">0</div>
        </div>
        <button id="new-game" class="bg-blue-600 text-white px-5 py-3 rounded-lg font-bold hover:bg-blue-700 transition-colors shadow-md">New Game</button>
    </div>

    <div id="game-container" class="relative touch-none">
        <div id="game-over-overlay" class="absolute inset-0 z-10 flex-col items-center justify-center bg-white/70 dark:bg-black/70 rounded-lg hidden">
            <p class="text-5xl font-extrabold text-gray-800 dark:text-white">Game Over!</p>
            <button id="try-again" class="mt-4 bg-blue-600 text-white px-5 py-3 rounded-lg font-bold hover:bg-blue-700 transition-colors shadow-md">Try Again</button>
        </div>

        <div id="grid-background" class="grid grid-cols-4 gap-3 bg-gray-400 dark:bg-gray-700 p-3 rounded-lg shadow-inner">
        </div>

        <div id="tile-container" class="absolute inset-0 p-3">
        </div>
    </div>
    
    <div class="mt-6 text-center text-sm text-gray-500 dark:text-gray-400 w-full max-w-sm">
        <p class="font-semibold">HOW TO PLAY:</p>
        <p>Use your <strong class="text-gray-700 dark:text-white">arrow keys</strong> or <strong class="text-gray-700 dark:text-white">swipe on the screen</strong> to move the tiles.</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('game-container');
            const gridBackground = document.getElementById('grid-background');
            const tileContainer = document.getElementById('tile-container');
            const scoreElement = document.getElementById('score');
            const newGameButton = document.getElementById('new-game');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const tryAgainButton = document.getElementById('try-again');

            const GRID_SIZE = 4;
            const TILE_BASE_SIZE = window.innerWidth < 768 ? 72 : 88;
            const GAP_SIZE = 12;

            let board = [];
            let score = 0;
            let isLocked = false;
            let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
            
            function getTilePosition(row, col) {
                return `translate(${col * (TILE_BASE_SIZE + GAP_SIZE)}px, ${row * (TILE_BASE_SIZE + GAP_SIZE)}px)`;
            }

            function setupBoard() {
                gridBackground.innerHTML = '';
                for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'w-[72px] h-[72px] md:w-[88px] md:h-[88px] bg-gray-300 dark:bg-gray-600 rounded-md';
                    gridBackground.appendChild(cell);
                }
            }

            function newGame() {
                board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
                score = 0;
                isLocked = false;
                updateScore(0, true);
                gameOverOverlay.classList.add('hidden');
                gameOverOverlay.classList.remove('flex');
                tileContainer.innerHTML = ''; // Clear old tiles immediately
                addRandomTile();
                addRandomTile();
            }

            function renderBoard(isNewGame = false) {
                board.forEach((row, rowIndex) => {
                    row.forEach((value, colIndex) => {
                        if (value !== 0) {
                            createTile(value, rowIndex, colIndex, isNewGame);
                        }
                    });
                });
            }

            function createTile(value, row, col, isNew = false) {
                const tile = document.createElement('div');
                const valueClass = value > 2048 ? 'tile-super' : `tile-${value}`;
                const sizeClass = 'w-[72px] h-[72px] md:w-[88px] md:h-[88px]';
                tile.className = `tile ${valueClass} ${sizeClass} absolute flex items-center justify-center rounded-md font-bold text-3xl md:text-4xl`;
                
                if (isNew) {
                    tile.classList.add('tile-new');
                }

                tile.textContent = value;
                tile.style.transform = getTilePosition(row, col);
                tileContainer.appendChild(tile);
            }

            function updateScore(points, reset = false) {
                if(reset) {
                    score = 0;
                } else if(points > 0) {
                    score += points;
                    scoreElement.classList.add('score-updated');
                    setTimeout(() => scoreElement.classList.remove('score-updated'), 300);
                }
                scoreElement.textContent = score;
            }

            function addRandomTile() {
                const emptyTiles = [];
                board.forEach((row, r) => row.forEach((cell, c) => {
                    if (cell === 0) emptyTiles.push({ r, c });
                }));

                if (emptyTiles.length > 0) {
                    const { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                    board[r][c] = Math.random() > 0.9 ? 4 : 2;
                    createTile(board[r][c], r, c, true); // Render only the new tile
                }
            }
            
            function move(direction) {
                if (isLocked) return;

                let boardChanged = false;
                const originalBoard = JSON.parse(JSON.stringify(board));

                if (direction === 'up' || direction === 'down') {
                    let transposed = transpose(board);
                    let processed = processBoard(transposed, direction);
                    board = transpose(processed.board);
                    boardChanged = !boardsAreSame(originalBoard, board);
                } else {
                    let processed = processBoard(board, direction);
                    board = processed.board;
                    boardChanged = !boardsAreSame(originalBoard, board);
                }

                if (boardChanged) {
                    isLocked = true;
                    // Animate movement
                    tileContainer.innerHTML = '';
                    renderBoard(); // Re-render the whole board with new positions
                    setTimeout(() => {
                        addRandomTile();
                        if (!canMove()) {
                           endGame();
                        }
                        isLocked = false;
                    }, 200);
                }
            }
            
            function processBoard(currentBoard, direction) {
                const newBoard = currentBoard.map(line => {
                    let forward = (direction === 'left' || direction === 'up');
                    let tempLine = forward ? line : line.slice().reverse();
                    let { newLine } = processLine(tempLine);
                    return forward ? newLine : newLine.reverse();
                });
                return { board: newBoard };
            }

            function processLine(line) {
                let filtered = line.filter(tile => tile !== 0);
                let scoreGained = 0;
                for (let i = 0; i < filtered.length - 1; i++) {
                    if (filtered[i] === filtered[i+1]) {
                        filtered[i] *= 2;
                        scoreGained += filtered[i];
                        filtered.splice(i + 1, 1);
                    }
                }
                updateScore(scoreGained);
                const newLine = Array(GRID_SIZE).fill(0);
                filtered.forEach((tile, i) => newLine[i] = tile);
                return { newLine, scoreGained };
            }

            function transpose(b) {
                return b[0].map((_, colIndex) => b.map(row => row[colIndex]));
            }

            function boardsAreSame(a, b) {
                return JSON.stringify(a) === JSON.stringify(b);
            }

            function canMove() {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (board[r][c] === 0) return true;
                        if (c < GRID_SIZE - 1 && board[r][c] === board[r][c + 1]) return true;
                        if (r < GRID_SIZE - 1 && board[r][c] === board[r + 1][c]) return true;
                    }
                }
                return false;
            }
            
            function endGame() {
                isLocked = true;
                gameOverOverlay.classList.remove('hidden');
                gameOverOverlay.classList.add('flex');
            }

            // Event Listeners
            document.addEventListener('keydown', e => {
                switch (e.key) {
                    case 'ArrowUp': move('up'); break;
                    case 'ArrowDown': move('down'); break;
                    case 'ArrowLeft': move('left'); break;
                    case 'ArrowRight': move('right'); break;
                }
            });
            
            // Touch Controls for Mobile
            gameContainer.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            gameContainer.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].clientX;
                touchEndY = e.changedTouches[0].clientY;
                handleSwipe();
            });

            function handleSwipe() {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const minSwipeDistance = 50; // Minimum distance to be considered a swipe

                if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
                    if (Math.abs(diffX) > minSwipeDistance) {
                        move(diffX > 0 ? 'right' : 'left');
                    }
                } else { // Vertical swipe
                    if (Math.abs(diffY) > minSwipeDistance) {
                        move(diffY > 0 ? 'down' : 'up');
                    }
                }
            }
            
            newGameButton.addEventListener('click', () => newGame(true));
            tryAgainButton.addEventListener('click', () => newGame(true));

            // Start Game
            setupBoard();
            newGame();
        });
    </script>
</body>
</html>
